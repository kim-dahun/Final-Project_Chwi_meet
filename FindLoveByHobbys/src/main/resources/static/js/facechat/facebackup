document.addEventListener('DOMContentLoaded', () => {

	let localVideo = document.querySelector('video#localVideo');
	let remoteVideo = document.querySelector('remoteVideo');
	let roomId = document.querySelector('input#roomId').value;
	let btnOffer = document.querySelector('button#btnOffer');


	let localStream;
	let remoteStream;




	const ws = 'ws://' + location.host + `/facechat?roomid=${roomId}`;

	const wss = new WebSocket(ws);

	wss.onopen = () => {

		console.log('WebSocket Connected');

	};

	wss.onclose = () => {

		console.log("WebSocket UnConnected")

	};

	function send(message) {
		wss.send(JSON.stringify(message));
	}

	// 먼저 RTC객체를 만들어요 구글 stun 서버로 부터 나의 정보를 가져올게요
	const configuration = {
		"iceServers": [{
			"url": "stun:stun.l.google.com:19302"
		}]
	}
	const myPeerConnection = new RTCPeerConnection(configuration);

	// 내가 나의 캔디데이트(너가 나를 연결하는 방법들의 후보)를 등록하면(즉 로컬디스크립션을 설정하면)
	// 트리거 되는 메서드에요
	myPeerConnection.onicecandidate = function(event) {
		console.log("나의 캔디데이트를 보낼게요");
		send({
			event: "candidate",
			data: event.candidate
		})
	}

	// 연결이 되서 피어의 스트림이 내 RTC객체에 등록되면 시작되는 메서드에요
	myPeerConnection.addEventListener("addstream", handleAddStream);
	function handleAddStream(data) {
		console.log("스트리밍 데이터를 받아왔어요");
		remoteVideo = document.getElementById("peerFace");
		remoteVideo.srcObject = data.stream;
	}

	// 소켓에서 메세지를 받아왔을 때 실행할 콜백함수에요
	wss.onmessage = async function(msg) {
		let content = JSON.parse(msg.data);
		if (content.event == "offer") {
			console.log("오퍼가 왔어요");
			// 오퍼가 오면 가장먼저 그 오퍼를 리모트 디스크립션으로 등록해줘요
			let offer = content.data;
			myPeerConnection.setRemoteDescription(offer);
			// 받는 쪽에서도 자신의 미디어를 켜줘요
			await getMedia();
			localStream.getTracks().forEach((track) => myPeerConnection.addTrack(track, localStream));
			// 이제 앤서를 보내요
			let answer = await myPeerConnection.createAnswer();
			myPeerConnection.setLocalDescription(answer);
			console.log("앤서를 보낼게요");
			send({
				event: "answer",
				data: answer
			})
		} else if (content.event == "answer") {
			console.log("앤서가 왔어요");
			answer = content.data;
			myPeerConnection.setRemoteDescription(answer);
		} else if (content.event == "candidate") {
			console.log("캔디데이트가 왔어요");
			// 이 메서드를 통해 리모트 디스크립션에 설정되어있는 피어와의 연결방식을 결정해요
			myPeerConnection.addIceCandidate(content.data);
		}
	}

	function webcam() {
		this.constraints = {
			video: true,
			audio: true
		};
		this.userMedia = null;
		this.mediaDevices = navigator.mediaDevices;

		this.initialize = async function() {
			try {
				this.userMedia = await this.mediaDevices.getUserMedia(this.constraints);
				console.log("미디어 스트림이 성공적으로 획득되었습니다.");
				localVideo.srcObject = this.userMedia;
				localStream = this.userMedia;
				localVideo.play();


			} catch (error) {
				console.error("미디어 장치에 접근하는 도중 오류가 발생했습니다:", error);
			}
		};
	}

	btnOffer.addEventListener('click', createOffer);

	// '오퍼를 생성해요'라는 버튼을 눌렀을 때 이 메서드가 실행되요
	async function createOffer() {
		console.log("오퍼를 보내볼게요");

		//일단 카메라를 킬게요 키면서 localStream에도 미디어 정보를 담아와요
		await webcam();

		// getMedia에서 가져온 audio, video 트랙을 myPeerConnection에 등록해요
		localStream.getTracks().forEach((track) => myPeerConnection.addTrack(track, localStream));

		// RTC객체도 만들었고 나의 미디어도 RTC객체에 담았으니 오퍼를 생성해볼게요
		let offer = await myPeerConnection.createOffer();
		console.log("오퍼를 전송시작해요!")
		// 이제 send함수를 통해 소켓으로 나의 offer를 전송해 볼게요
		await send({
			event: "offer",
			data: offer
		})
		console.log("오퍼 전송을 완료했어요")
		myPeerConnection.setLocalDescription(offer);
	}







})